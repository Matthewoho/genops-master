// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.6

package models

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	uSERSFieldNames          = builder.RawFieldNames(&USERS{})
	uSERSRows                = strings.Join(uSERSFieldNames, ",")
	uSERSRowsExpectAutoSet   = strings.Join(stringx.Remove(uSERSFieldNames, "`ID`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	uSERSRowsWithPlaceHolder = strings.Join(stringx.Remove(uSERSFieldNames, "`ID`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"
)

type (
	uSERSModel interface {
		Insert(ctx context.Context, data *USERS) (sql.Result, error)
		FindOne(ctx context.Context, iD int64) (*USERS, error)
		FindOneByUSERNAME(ctx context.Context, uSERNAME string) (*USERS, error)
		Update(ctx context.Context, data *USERS) error
		Delete(ctx context.Context, iD int64) error
	}

	defaultUSERSModel struct {
		conn  sqlx.SqlConn
		table string
	}

	USERS struct {
		ID                   int64          `db:"ID"`
		USERNAME             string         `db:"USERNAME"`
		REALNAME             sql.NullString `db:"REALNAME"`
		PASSWORD             string         `db:"PASSWORD"`
		SALT                 sql.NullString `db:"SALT"`
		EMAIL                sql.NullString `db:"EMAIL"`
		PHONE                sql.NullString `db:"PHONE"`
		ROLECODE             sql.NullString `db:"ROLE_CODE"`
		ROLENAME             sql.NullString `db:"ROLE_NAME"`
		STATUS               sql.NullInt64  `db:"STATUS"`
		DELFLAG              int64          `db:"DEL_FLAG"`
		REMARK               sql.NullString `db:"REMARK"`
		CREATEBY             sql.NullString `db:"CREATE_BY"`
		CREATEAT             sql.NullInt64  `db:"CREATE_AT"`
		UPDATEBY             sql.NullString `db:"UPDATE_BY"`
		UPDATEAT             sql.NullInt64  `db:"UPDATE_AT"`
		CLIENTIP             sql.NullString `db:"CLIENT_IP"`
		FAILEDCNT            int64          `db:"FAILED_CNT"`
		NICKNAME             sql.NullString `db:"NICKNAME"`
		DEPARTMENT           sql.NullString `db:"DEPARTMENT"`
		ENNAME               sql.NullString `db:"EN_NAME"`
		AVATAR               sql.NullString `db:"AVATAR"`
		ISADMIN              int64          `db:"IS_ADMIN"`
		LASTLOGINAT          sql.NullInt64  `db:"LAST_LOGIN_AT"`
		CREATEDIP            sql.NullString `db:"CREATED_IP"`
		LASTPASSWORDCHANGEAT sql.NullInt64  `db:"LAST_PASSWORD_CHANGE_AT"`
		TWOFACTORENABLED     int64          `db:"TWO_FACTOR_ENABLED"`
	}
)

func newUSERSModel(conn sqlx.SqlConn) *defaultUSERSModel {
	return &defaultUSERSModel{
		conn:  conn,
		table: "`USERS`",
	}
}

func (m *defaultUSERSModel) Delete(ctx context.Context, iD int64) error {
	query := fmt.Sprintf("delete from %s where `ID` = ?", m.table)
	_, err := m.conn.ExecCtx(ctx, query, iD)
	return err
}

func (m *defaultUSERSModel) FindOne(ctx context.Context, iD int64) (*USERS, error) {
	query := fmt.Sprintf("select %s from %s where `ID` = ? limit 1", uSERSRows, m.table)
	var resp USERS
	err := m.conn.QueryRowCtx(ctx, &resp, query, iD)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultUSERSModel) FindOneByUSERNAME(ctx context.Context, uSERNAME string) (*USERS, error) {
	var resp USERS
	query := fmt.Sprintf("select %s from %s where `USERNAME` = ? limit 1", uSERSRows, m.table)
	err := m.conn.QueryRowCtx(ctx, &resp, query, uSERNAME)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultUSERSModel) Insert(ctx context.Context, data *USERS) (sql.Result, error) {
	query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, uSERSRowsExpectAutoSet)
	ret, err := m.conn.ExecCtx(ctx, query, data.USERNAME, data.REALNAME, data.PASSWORD, data.SALT, data.EMAIL, data.PHONE, data.ROLECODE, data.ROLENAME, data.STATUS, data.DELFLAG, data.REMARK, data.CREATEBY, data.CREATEAT, data.UPDATEBY, data.UPDATEAT, data.CLIENTIP, data.FAILEDCNT, data.NICKNAME, data.DEPARTMENT, data.ENNAME, data.AVATAR, data.ISADMIN, data.LASTLOGINAT, data.CREATEDIP, data.LASTPASSWORDCHANGEAT, data.TWOFACTORENABLED)
	return ret, err
}

func (m *defaultUSERSModel) Update(ctx context.Context, newData *USERS) error {
	query := fmt.Sprintf("update %s set %s where `ID` = ?", m.table, uSERSRowsWithPlaceHolder)
	_, err := m.conn.ExecCtx(ctx, query, newData.USERNAME, newData.REALNAME, newData.PASSWORD, newData.SALT, newData.EMAIL, newData.PHONE, newData.ROLECODE, newData.ROLENAME, newData.STATUS, newData.DELFLAG, newData.REMARK, newData.CREATEBY, newData.CREATEAT, newData.UPDATEBY, newData.UPDATEAT, newData.CLIENTIP, newData.FAILEDCNT, newData.NICKNAME, newData.DEPARTMENT, newData.ENNAME, newData.AVATAR, newData.ISADMIN, newData.LASTLOGINAT, newData.CREATEDIP, newData.LASTPASSWORDCHANGEAT, newData.TWOFACTORENABLED, newData.ID)
	return err
}

func (m *defaultUSERSModel) tableName() string {
	return m.table
}
